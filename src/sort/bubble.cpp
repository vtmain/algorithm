#include "sort.h"

void bubble(int arr[], int len)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				swap(arr, j, j + 1);
			}
		}
	}
}

// 过程解析
void bubble_detail(int arr[], int len)
{
	// 举例：10个数
	//    [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]
	//    10    9    8    7    6    5    4    3    2    1
	//
	for (int i = 0; i < len - 1; i++)
	{
		// 外层控制：
		//       i: 已经比较过的数字数量
		//          每一轮都是固定从左至右，只不过结束位置不同，每跑完一轮，就少一个
		//          每跑一轮，最右边的数字一定就是最大值
		//          像上面的例子，第1轮之后
		//              10就换到了最右边，左边还剩9个
		//              最后剩1个时不用比，每轮至少2个数
		//              实际剩下8个需要比较
		//   len-1: 总共需要比较的数字数量(固定值)，这里的数量明明是10个数，为啥要-1呢
		//          代码实际跑循环是先内层后外层，这里之所以是len-1，而不是len，主要是受内层循环限制
		//          内层比较时用n和n+1比，所以j控制在len-1即可，反馈到外层循环，数量自然少一个
		//          len-1主要为了限定n的范围，n+1才不会越界
		//          假如把len-1替换为一个变量max_n，那么 i<max_n 和内层的 j<max_n-i 就好理解了
		//          (len-1) = max_n = 9
		for (int j = 0; j < len - 1 - i; j++)
		{
			// 内层控制：每一轮需要多少次比较 
			//          每次都是从最左边开始，比较剩余的数字，两两比较
			// len-1: 含义不变，max_n
			//    -i: 再减去每轮已经比较过的数字数量，剩下的就是本轮需要比较的数字数量
			//
			// 第1轮，i=0，len-1-i=9，共需要9次比较(j: 0->8)
			//    第1次: j=0, 比较 10-9 换位 [9, 10, 8, 7, 6, 5, 4, 3, 2, 1]
			//    第2次: j=1, 比较 10-8 换位 [9, 8, 10, 7, 6, 5, 4, 3, 2, 1]
			//    ...
			//    第9次: j=8, 比较 10-1 换位 [9, 8, 7, 6, 5, 4, 3, 2, 1, 10]
			// 第2轮：i=1，len-1-i=8，共需要8次比较(j: 0->7)
			//    第1次: j=0, 比较 9-8 换位 [8, 9, 7, 6, 5, 4, 3, 2, 1, 10]
			//    第2次: j=1, 比较 9-7 换位 [8, 7, 9, 6, 5, 4, 3, 2, 1, 10]
			//    ...
			//    第8次: j=7, 比较 9-1 换位 [8, 7, 6, 5, 4, 3, 2, 1, 9, 10]
			// ...
			// 第n轮 同理
			// ...
			if (arr[j] > arr[j + 1])
			{
				swap(arr, j, j + 1);
			}
		}
	}
}